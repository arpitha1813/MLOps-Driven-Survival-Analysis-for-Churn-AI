<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="7" time="19.761" timestamp="2025-01-05T12:31:33.757555+05:30" hostname="Arpitha"><testcase classname="tests.test_data_validation" name="test_missing_value_handling" time="2.189" /><testcase classname="tests.test_data_validation" name="test_column_names" time="1.762" /><testcase classname="tests.test_data_validation" name="test_data_types" time="1.821" /><testcase classname="tests.test_feature_engineering" name="test_missing_value_imputation" time="1.798"><failure message="TypeError: could not convert string to float: '3668-QPYBK'">values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
&gt;               values = values.astype("f8")
E               ValueError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:789: ValueError

The above exception was the direct cause of the following exception:

load_data =       CustomerID  Count        Country       State  ... Churn Value  Churn Score  CLTV                   Churn Reason
... United States  California  ...           0           38  5097                            NaN

[7043 rows x 33 columns]

    def test_missing_value_imputation(load_data):
        df = load_data
        df_with_missing_values = df.copy()
        df_with_missing_values['Churn Score'] = None  # Introduce some missing values
&gt;       df_filled = feature_engineering(df_with_missing_values)

tests\test_feature_engineering.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_feature_engineering.py:9: in feature_engineering
    df.fillna(df.median(), inplace=True)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11706: in median
    result = super().median(axis, skipna, numeric_only, **kwargs)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12431: in median
    return self._stat_function(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12377: in _stat_function
    return self._reduce(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11562: in _reduce
    res = df._mgr.reduce(blk_func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\managers.py:1500: in reduce
    nbs = blk.reduce(func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\blocks.py:404: in reduce
    result = func(self.values)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11481: in blk_func
    return op(values, axis=axis, skipna=skipna, **kwds)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:147: in f
    result = alt(values, axis=axis, skipna=skipna, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
                values = values.astype("f8")
            except ValueError as err:
                # e.g. "could not convert string to float: 'a'"
&gt;               raise TypeError(str(err)) from err
E               TypeError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:792: TypeError</failure></testcase><testcase classname="tests.test_feature_engineering" name="test_feature_scaling" time="1.739"><failure message="TypeError: could not convert string to float: '3668-QPYBK'">values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
&gt;               values = values.astype("f8")
E               ValueError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:789: ValueError

The above exception was the direct cause of the following exception:

load_data =       CustomerID  Count        Country       State  ... Churn Value  Churn Score  CLTV                   Churn Reason
... United States  California  ...           0           38  5097                            NaN

[7043 rows x 33 columns]

    def test_feature_scaling(load_data):
        df = load_data
&gt;       df_scaled = feature_engineering(df)

tests\test_feature_engineering.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_feature_engineering.py:9: in feature_engineering
    df.fillna(df.median(), inplace=True)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11706: in median
    result = super().median(axis, skipna, numeric_only, **kwargs)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12431: in median
    return self._stat_function(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12377: in _stat_function
    return self._reduce(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11562: in _reduce
    res = df._mgr.reduce(blk_func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\managers.py:1500: in reduce
    nbs = blk.reduce(func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\blocks.py:404: in reduce
    result = func(self.values)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11481: in blk_func
    return op(values, axis=axis, skipna=skipna, **kwds)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:147: in f
    result = alt(values, axis=axis, skipna=skipna, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
                values = values.astype("f8")
            except ValueError as err:
                # e.g. "could not convert string to float: 'a'"
&gt;               raise TypeError(str(err)) from err
E               TypeError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:792: TypeError</failure></testcase><testcase classname="tests.test_feature_engineering" name="test_label_encoding" time="1.854"><failure message="TypeError: could not convert string to float: '3668-QPYBK'">values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
&gt;               values = values.astype("f8")
E               ValueError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:789: ValueError

The above exception was the direct cause of the following exception:

load_data =       CustomerID  Count        Country       State  ... Churn Value  Churn Score  CLTV                   Churn Reason
... United States  California  ...           0           38  5097                            NaN

[7043 rows x 33 columns]

    def test_label_encoding(load_data):
        df = load_data
&gt;       df_encoded = feature_engineering(df)

tests\test_feature_engineering.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_feature_engineering.py:9: in feature_engineering
    df.fillna(df.median(), inplace=True)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11706: in median
    result = super().median(axis, skipna, numeric_only, **kwargs)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12431: in median
    return self._stat_function(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12377: in _stat_function
    return self._reduce(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11562: in _reduce
    res = df._mgr.reduce(blk_func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\managers.py:1500: in reduce
    nbs = blk.reduce(func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\blocks.py:404: in reduce
    result = func(self.values)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11481: in blk_func
    return op(values, axis=axis, skipna=skipna, **kwds)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:147: in f
    result = alt(values, axis=axis, skipna=skipna, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
                values = values.astype("f8")
            except ValueError as err:
                # e.g. "could not convert string to float: 'a'"
&gt;               raise TypeError(str(err)) from err
E               TypeError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:792: TypeError</failure></testcase><testcase classname="tests.test_feature_engineering" name="test_feature_engineering_pipeline" time="1.810"><failure message="TypeError: could not convert string to float: '3668-QPYBK'">values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
&gt;               values = values.astype("f8")
E               ValueError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:789: ValueError

The above exception was the direct cause of the following exception:

load_data =       CustomerID  Count        Country       State  ... Churn Value  Churn Score  CLTV                   Churn Reason
... United States  California  ...           0           38  5097                            NaN

[7043 rows x 33 columns]

    def test_feature_engineering_pipeline(load_data):
        df = load_data
        # Test if the entire pipeline runs without issues
&gt;       df_transformed = feature_engineering(df)

tests\test_feature_engineering.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_feature_engineering.py:9: in feature_engineering
    df.fillna(df.median(), inplace=True)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11706: in median
    result = super().median(axis, skipna, numeric_only, **kwargs)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12431: in median
    return self._stat_function(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\generic.py:12377: in _stat_function
    return self._reduce(
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11562: in _reduce
    res = df._mgr.reduce(blk_func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\managers.py:1500: in reduce
    nbs = blk.reduce(func)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\internals\blocks.py:404: in reduce
    result = func(self.values)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\frame.py:11481: in blk_func
    return op(values, axis=axis, skipna=skipna, **kwds)
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:147: in f
    result = alt(values, axis=axis, skipna=skipna, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([['3668-QPYBK', '9237-HQITU', '9305-CDSKC', ..., '2234-XADUH',
        '4801-JZAZL', '3186-AJIEK'],
       ['Uni...No', 'No', 'No'],
       ['Competitor made better offer', 'Moved', 'Moved', ..., nan, nan,
        nan]], dtype=object)

    @bottleneck_switch()
    def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask=None):
        """
        Parameters
        ----------
        values : ndarray
        axis : int, optional
        skipna : bool, default True
        mask : ndarray[bool], optional
            nan-mask if known
    
        Returns
        -------
        result : float
            Unless input is a float array, in which case use the same
            precision as the input array.
    
        Examples
        --------
        &gt;&gt;&gt; from pandas.core import nanops
        &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
        &gt;&gt;&gt; nanops.nanmedian(s.values)
        2.0
        """
        # for floats without mask, the data already uses NaN as missing value
        # indicator, and `mask` will be calculated from that below -&gt; in those
        # cases we never need to set NaN to the masked values
        using_nan_sentinel = values.dtype.kind == "f" and mask is None
    
        def get_median(x, _mask=None):
            if _mask is None:
                _mask = notna(x)
            else:
                _mask = ~_mask
            if not skipna and not _mask.all():
                return np.nan
            with warnings.catch_warnings():
                # Suppress RuntimeWarning about All-NaN slice
                warnings.filterwarnings(
                    "ignore", "All-NaN slice encountered", RuntimeWarning
                )
                res = np.nanmedian(x[_mask])
            return res
    
        dtype = values.dtype
        values, mask = _get_values(values, skipna, mask=mask, fill_value=None)
        if values.dtype.kind != "f":
            if values.dtype == object:
                # GH#34671 avoid casting strings to numeric
                inferred = lib.infer_dtype(values)
                if inferred in ["string", "mixed"]:
                    raise TypeError(f"Cannot convert {values} to numeric")
            try:
                values = values.astype("f8")
            except ValueError as err:
                # e.g. "could not convert string to float: 'a'"
&gt;               raise TypeError(str(err)) from err
E               TypeError: could not convert string to float: '3668-QPYBK'

..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\nanops.py:792: TypeError</failure></testcase></testsuite></testsuites>